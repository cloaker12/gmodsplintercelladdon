-- ============================================================================
-- ULTRA-ENHANCED SPLINTER CELL ENVIRONMENTAL EFFECTS SYSTEM
-- ============================================================================
-- Advanced weather simulation, environmental hazards, EMP effects,
-- atmospheric modeling, and dynamic world interaction systems
-- ============================================================================

if CLIENT then
    -- ============================================================================
    -- ADVANCED WEATHER SIMULATION SYSTEM
    -- ============================================================================
    
    local WeatherSystem = {
        -- Current Weather State
        current = {
            type = "clear",
            intensity = 0,
            visibility = 1.0,
            precipitation = 0,
            cloud_cover = 0,
            wind_speed = 0,
            wind_direction = 0,
            temperature = 20,
            humidity = 45,
            pressure = 1013.25,
            fog_density = 0,
            storm_activity = 0
        },
        
        -- Weather Types
        types = {
            clear = {
                visibility_modifier = 1.0,
                detection_modifier = 1.0,
                thermal_modifier = 1.0,
                sound_modifier = 1.0
            },
            cloudy = {
                visibility_modifier = 0.9,
                detection_modifier = 0.95,
                thermal_modifier = 0.9,
                sound_modifier = 1.1
            },
            overcast = {
                visibility_modifier = 0.8,
                detection_modifier = 0.9,
                thermal_modifier = 0.8,
                sound_modifier = 1.2
            },
            light_rain = {
                visibility_modifier = 0.7,
                detection_modifier = 0.8,
                thermal_modifier = 0.7,
                sound_modifier = 1.5
            },
            heavy_rain = {
                visibility_modifier = 0.5,
                detection_modifier = 0.6,
                thermal_modifier = 0.5,
                sound_modifier = 2.0
            },
            thunderstorm = {
                visibility_modifier = 0.3,
                detection_modifier = 0.4,
                thermal_modifier = 0.4,
                sound_modifier = 3.0
            },
            fog = {
                visibility_modifier = 0.2,
                detection_modifier = 0.3,
                thermal_modifier = 0.6,
                sound_modifier = 0.8
            },
            snow = {
                visibility_modifier = 0.6,
                detection_modifier = 0.7,
                thermal_modifier = 0.3,
                sound_modifier = 0.7
            },
            blizzard = {
                visibility_modifier = 0.1,
                detection_modifier = 0.2,
                thermal_modifier = 0.1,
                sound_modifier = 2.5
            },
            sandstorm = {
                visibility_modifier = 0.15,
                detection_modifier = 0.25,
                thermal_modifier = 0.8,
                sound_modifier = 2.0
            }
        },
        
        -- Dynamic Weather Parameters
        dynamics = {
            change_rate = 0.001,
            randomness = 0.1,
            seasonal_bias = 0,
            time_factor = 1.0
        },
        
        -- Weather Effects
        effects = {
            particles = {},
            sounds = {},
            visual_modifiers = {},
            physics_modifiers = {}
        }
    }
    
    -- Weather simulation function
    local function UpdateWeatherSystem()
        local currentTime = CurTime()
        local weather = WeatherSystem.current
        local dynamics = WeatherSystem.dynamics
        
        -- Simulate weather changes
        if math.random() < dynamics.change_rate then
            local weatherTypes = {\"clear\", \"cloudy\", \"overcast\", \"light_rain\", \"heavy_rain\", \"fog\", \"snow\"}\n            if math.random() < 0.1 then -- Rare weather\n                table.insert(weatherTypes, \"thunderstorm\")\n                table.insert(weatherTypes, \"blizzard\")\n                table.insert(weatherTypes, \"sandstorm\")\n            end\n            \n            local newWeatherType = weatherTypes[math.random(#weatherTypes)]\n            if newWeatherType != weather.type then\n                weather.type = newWeatherType\n                weather.intensity = math.random(10, 100) / 100\n                \n                LocalPlayer():ChatPrint(\"[WEATHER] Weather changed to: \" .. weather.type)\n                surface.PlaySound(\"ambient/wind/wind_snippet1.wav\")\n            end\n        end\n        \n        -- Update weather parameters based on type\n        local weatherData = WeatherSystem.types[weather.type]\n        if weatherData then\n            weather.visibility = math.max(0.1, weatherData.visibility_modifier * (1 - weather.intensity * 0.5))\n            \n            -- Update atmospheric conditions\n            if weather.type == \"thunderstorm\" then\n                weather.storm_activity = math.min(100, weather.storm_activity + 1)\n                \n                -- Random lightning effects\n                if math.random() < 0.02 then\n                    -- Lightning flash effect\n                    local flash = vgui.Create(\"DPanel\")\n                    flash:SetSize(ScrW(), ScrH())\n                    flash:SetPos(0, 0)\n                    flash:SetBackgroundColor(Color(255, 255, 255, 150))\n                    flash:MakePopup()\n                    flash:SetMouseInputEnabled(false)\n                    flash:SetKeyboardInputEnabled(false)\n                    \n                    timer.Simple(0.1, function()\n                        if IsValid(flash) then\n                            flash:Remove()\n                        end\n                    end)\n                    \n                    -- Thunder sound\n                    timer.Simple(math.random(1, 3), function()\n                        surface.PlaySound(\"ambient/explosions/explode_9.wav\")\n                    end)\n                end\n            else\n                weather.storm_activity = math.max(0, weather.storm_activity - 0.5)\n            end\n        end\n    end\n    \n    -- ============================================================================\n    -- ELECTROMAGNETIC PULSE (EMP) SIMULATION SYSTEM\n    -- ============================================================================\n    \n    local EMPSystem = {\n        -- EMP Sources\n        sources = {},\n        \n        -- EMP Effects\n        effects = {\n            duration = 0,\n            intensity = 0,\n            center = Vector(0, 0, 0),\n            radius = 0,\n            frequency_disruption = {},\n            electronic_failure = {}\n        },\n        \n        -- Shielding\n        shielding = {\n            faraday_cage = false,\n            emp_hardening = 0.1,\n            redundant_systems = false\n        },\n        \n        -- Recovery Systems\n        recovery = {\n            auto_reboot = true,\n            backup_power = true,\n            system_restore = true\n        }\n    }\n    \n    -- EMP effect simulation\n    local function SimulateEMPEffect(center, radius, intensity)\n        local ply = LocalPlayer()\n        local distance = ply:GetPos():Distance(center)\n        \n        if distance <= radius then\n            -- Calculate EMP intensity based on distance\n            local effectIntensity = intensity * (1 - (distance / radius))\n            \n            EMPSystem.effects.duration = 10 + (effectIntensity * 20)\n            EMPSystem.effects.intensity = effectIntensity\n            EMPSystem.effects.center = center\n            EMPSystem.effects.radius = radius\n            \n            -- Apply EMP effects to NVG system\n            if visionActive then\n                -- System interference\n                local interferenceLevel = effectIntensity * (1 - EMPSystem.shielding.emp_hardening)\n                \n                if interferenceLevel > 0.3 then\n                    -- Temporary system shutdown\n                    visionActive = false\n                    systemTemp = systemTemp + (interferenceLevel * 30)\n                    battery = battery - (interferenceLevel * 20)\n                    \n                    LocalPlayer():ChatPrint(\"[EMP] Electronic systems disrupted!\")\n                    surface.PlaySound(\"ambient/energy/electric_loop.wav\")\n                    \n                    -- Visual interference\n                    timer.Create(\"EMPInterference\", 0.1, EMPSystem.effects.duration * 10, function()\n                        if math.random() < interferenceLevel then\n                            -- Screen static effect\n                            local static = vgui.Create(\"DPanel\")\n                            static:SetSize(ScrW(), ScrH())\n                            static:SetPos(0, 0)\n                            static:SetBackgroundColor(Color(0, 0, 0, 0))\n                            static:MakePopup()\n                            static:SetMouseInputEnabled(false)\n                            static:SetKeyboardInputEnabled(false)\n                            \n                            function static:Paint(w, h)\n                                for i = 1, 50 do\n                                    local x = math.random(0, w)\n                                    local y = math.random(0, h)\n                                    local size = math.random(1, 3)\n                                    draw.RoundedBox(0, x, y, size, size, Color(255, 255, 255, math.random(50, 150)))\n                                end\n                            end\n                            \n                            timer.Simple(0.05, function()\n                                if IsValid(static) then\n                                    static:Remove()\n                                end\n                            end)\n                        end\n                    end)\n                    \n                    -- Auto-recovery if enabled\n                    if EMPSystem.recovery.auto_reboot then\n                        timer.Simple(EMPSystem.effects.duration, function()\n                            if EMPSystem.recovery.system_restore then\n                                LocalPlayer():ChatPrint(\"[SYSTEM] Auto-recovery initiated...\")\n                                surface.PlaySound(\"buttons/button9.wav\")\n                                \n                                timer.Simple(2, function()\n                                    LocalPlayer():ChatPrint(\"[SYSTEM] Systems restored\")\n                                    surface.PlaySound(\"buttons/button3.wav\")\n                                end)\n                            end\n                        end)\n                    end\n                end\n            end\n        end\n    end\n    \n    -- ============================================================================\n    -- ATMOSPHERIC MODELING SYSTEM\n    -- ============================================================================\n    \n    local AtmosphereSystem = {\n        -- Atmospheric Layers\n        layers = {\n            troposphere = {height_range = {0, 12000}, temperature_gradient = -6.5}, -- °C per km\n            stratosphere = {height_range = {12000, 50000}, temperature_gradient = 2.0},\n            mesosphere = {height_range = {50000, 85000}, temperature_gradient = -2.8},\n            thermosphere = {height_range = {85000, 600000}, temperature_gradient = 12.0}\n        },\n        \n        -- Gas Composition\n        composition = {\n            nitrogen = 0.78084,\n            oxygen = 0.20946,\n            argon = 0.00934,\n            carbon_dioxide = 0.000412,\n            neon = 0.00001818,\n            helium = 0.00000524,\n            methane = 0.00000179,\n            krypton = 0.00000114\n        },\n        \n        -- Atmospheric Properties\n        properties = {\n            pressure = 101325, -- Pa at sea level\n            density = 1.225, -- kg/m³ at sea level\n            temperature = 288.15, -- K at sea level\n            humidity = 0.5, -- relative humidity\n            viscosity = 1.81e-5 -- Pa·s\n        },\n        \n        -- Pollution and Contamination\n        contamination = {\n            particulates = {\n                pm25 = 0, -- µg/m³\n                pm10 = 0,\n                dust = 0,\n                smoke = 0,\n                pollen = 0\n            },\n            gases = {\n                carbon_monoxide = 0,\n                sulfur_dioxide = 0,\n                nitrogen_dioxide = 0,\n                ozone = 0,\n                ammonia = 0\n            },\n            toxicity_level = 0,\n            radiation_level = 0.1 -- µSv/h background\n        }\n    }\n    \n    -- Calculate atmospheric properties at altitude\n    local function CalculateAtmosphericProperties(altitude)\n        local properties = {}\n        \n        -- Determine atmospheric layer\n        local layer = nil\n        for layerName, layerData in pairs(AtmosphereSystem.layers) do\n            if altitude >= layerData.height_range[1] and altitude < layerData.height_range[2] then\n                layer = layerData\n                break\n            end\n        end\n        \n        if not layer then\n            layer = AtmosphereSystem.layers.troposphere -- Default to troposphere\n        end\n        \n        -- Calculate temperature\n        local heightInLayer = altitude - layer.height_range[1]\n        properties.temperature = 288.15 + (layer.temperature_gradient * heightInLayer / 1000)\n        \n        -- Calculate pressure (barometric formula)\n        properties.pressure = 101325 * math.pow((1 - 0.0065 * altitude / 288.15), 5.255)\n        \n        -- Calculate density\n        properties.density = properties.pressure / (287 * properties.temperature)\n        \n        -- Calculate humidity effects\n        local saturation_vapor_pressure = 610.78 * math.exp(17.27 * (properties.temperature - 273.15) / (properties.temperature - 35.86))\n        properties.humidity_ratio = AtmosphereSystem.properties.humidity * saturation_vapor_pressure / properties.pressure\n        \n        return properties\n    end\n    \n    -- ============================================================================\n    -- RADIATION AND HAZARD DETECTION SYSTEM\n    -- ============================================================================\n    \n    local RadiationSystem = {\n        -- Radiation Sources\n        sources = {},\n        \n        -- Radiation Types\n        types = {\n            alpha = {penetration = 0.1, danger_level = 1.0},\n            beta = {penetration = 0.3, danger_level = 1.5},\n            gamma = {penetration = 1.0, danger_level = 2.0},\n            neutron = {penetration = 0.8, danger_level = 3.0},\n            xray = {penetration = 0.7, danger_level = 1.2}\n        },\n        \n        -- Safety Levels (µSv/h)\n        safety_levels = {\n            safe = 1.0,\n            elevated = 10.0,\n            caution = 100.0,\n            danger = 1000.0,\n            lethal = 10000.0\n        },\n        \n        -- Detection Equipment\n        detector = {\n            sensitivity = 1.0,\n            calibration = 1.0,\n            background_subtraction = true,\n            energy_discrimination = true\n        },\n        \n        -- Exposure Tracking\n        exposure = {\n            cumulative_dose = 0, -- mSv\n            dose_rate = 0, -- µSv/h\n            exposure_time = 0, -- hours\n            safety_limit = 20 -- mSv per year\n        }\n    }\n    \n    -- Simulate radiation detection\n    local function DetectRadiation(position)\n        local totalRadiation = AtmosphereSystem.contamination.radiation_level\n        \n        -- Check for artificial radiation sources\n        for _, source in ipairs(RadiationSystem.sources) do\n            local distance = position:Distance(source.position)\n            if distance < source.range then\n                -- Inverse square law\n                local intensity = source.intensity / math.pow(distance / 100, 2)\n                totalRadiation = totalRadiation + intensity\n            end\n        end\n        \n        -- Update exposure tracking\n        RadiationSystem.exposure.dose_rate = totalRadiation\n        RadiationSystem.exposure.cumulative_dose = RadiationSystem.exposure.cumulative_dose + (totalRadiation * 0.001) -- Convert µSv to mSv\n        \n        -- Determine safety level\n        local safety_status = \"safe\"\n        if totalRadiation > RadiationSystem.safety_levels.lethal then\n            safety_status = \"lethal\"\n        elseif totalRadiation > RadiationSystem.safety_levels.danger then\n            safety_status = \"danger\"\n        elseif totalRadiation > RadiationSystem.safety_levels.caution then\n            safety_status = \"caution\"\n        elseif totalRadiation > RadiationSystem.safety_levels.elevated then\n            safety_status = \"elevated\"\n        end\n        \n        return {\n            level = totalRadiation,\n            safety_status = safety_status,\n            cumulative_dose = RadiationSystem.exposure.cumulative_dose\n        }\n    end\n    \n    -- ============================================================================\n    -- SEISMIC ACTIVITY SIMULATION\n    -- ============================================================================\n    \n    local SeismicSystem = {\n        -- Current Activity\n        activity = {\n            magnitude = 0,\n            epicenter = Vector(0, 0, 0),\n            depth = 0,\n            duration = 0,\n            frequency = 0\n        },\n        \n        -- Earthquake Scales\n        richter_scale = {\n            [0] = {description = \"Micro\", effects = \"Not felt\"},\n            [1] = {description = \"Minor\", effects = \"Rarely felt\"},\n            [2] = {description = \"Minor\", effects = \"Felt by few\"},\n            [3] = {description = \"Light\", effects = \"Felt by many\"},\n            [4] = {description = \"Moderate\", effects = \"Everyone feels it\"},\n            [5] = {description = \"Strong\", effects = \"Damage to weak structures\"},\n            [6] = {description = \"Strong\", effects = \"Damage to well-built structures\"},\n            [7] = {description = \"Major\", effects = \"Serious damage\"},\n            [8] = {description = \"Great\", effects = \"Severe damage\"},\n            [9] = {description = \"Great\", effects = \"Devastating\"}\n        },\n        \n        -- Monitoring\n        monitoring = {\n            sensitivity = 1.0,\n            detection_range = 10000, -- meters\n            early_warning = true,\n            prediction_accuracy = 0.7\n        }\n    }\n    \n    -- Simulate seismic activity\n    local function SimulateSeismicActivity()\n        if math.random() < 0.001 then -- Rare occurrence\n            local magnitude = math.random(1, 6) + math.random()\n            local ply = LocalPlayer()\n            local epicenter = ply:GetPos() + Vector(math.random(-5000, 5000), math.random(-5000, 5000), 0)\n            local depth = math.random(1000, 10000)\n            \n            SeismicSystem.activity = {\n                magnitude = magnitude,\n                epicenter = epicenter,\n                depth = depth,\n                duration = magnitude * 5, -- seconds\n                frequency = 1 + (magnitude / 10)\n            }\n            \n            local distance = ply:GetPos():Distance(epicenter)\n            local felt_magnitude = magnitude - (distance / 1000) -- Magnitude decreases with distance\n            \n            if felt_magnitude > 2 then\n                LocalPlayer():ChatPrint(string.format(\"[SEISMIC] Earthquake detected: Magnitude %.1f\", felt_magnitude))\n                \n                -- Visual shaking effect\n                local shake_duration = felt_magnitude * 2\n                local shake_intensity = felt_magnitude / 10\n                \n                timer.Create(\"SeismicShake\", 0.05, shake_duration * 20, function()\n                    local shake_x = math.random(-shake_intensity, shake_intensity)\n                    local shake_y = math.random(-shake_intensity, shake_intensity)\n                    \n                    -- This would ideally modify the view angles, but for compatibility we'll use screen effects\n                    if math.random() < shake_intensity then\n                        surface.PlaySound(\"physics/concrete/rock_impact_hard\" .. math.random(1, 6) .. \".wav\")\n                    end\n                end)\n                \n                -- Affect NVG systems\n                if visionActive and felt_magnitude > 4 then\n                    systemTemp = systemTemp + felt_magnitude\n                    LocalPlayer():ChatPrint(\"[NVG] Seismic activity affecting system stability\")\n                end\n            end\n        end\n    end\n    \n    -- ============================================================================\n    -- MAIN ENVIRONMENTAL SYSTEMS UPDATE LOOP\n    -- ============================================================================\n    \n    local lastEnvironmentalUpdate = 0\n    \n    local function UpdateEnvironmentalSystems()\n        local currentTime = CurTime()\n        \n        -- Update every 0.5 seconds\n        if currentTime - lastEnvironmentalUpdate < 0.5 then return end\n        lastEnvironmentalUpdate = currentTime\n        \n        local ply = LocalPlayer()\n        if not IsValid(ply) then return end\n        \n        local position = ply:GetPos()\n        local altitude = position.z\n        \n        -- Update weather system\n        UpdateWeatherSystem()\n        \n        -- Update atmospheric properties\n        local atmospheric = CalculateAtmosphericProperties(altitude)\n        \n        -- Update radiation detection\n        local radiation = DetectRadiation(position)\n        \n        -- Update seismic monitoring\n        SimulateSeismicActivity()\n        \n        -- Apply environmental effects to NVG system\n        if visionActive then\n            local weather = WeatherSystem.current\n            local weatherData = WeatherSystem.types[weather.type]\n            \n            if weatherData then\n                -- Reduce vision effectiveness in bad weather\n                local visibilityReduction = (1 - weatherData.visibility_modifier) * weather.intensity\n                \n                -- Increase power consumption in harsh conditions\n                if weather.type == \"thunderstorm\" or weather.type == \"blizzard\" then\n                    battery = battery - 0.1\n                    systemTemp = systemTemp + 0.5\n                end\n                \n                -- EMP effects during thunderstorms\n                if weather.type == \"thunderstorm\" and weather.storm_activity > 50 then\n                    if math.random() < 0.01 then -- Rare EMP from lightning\n                        SimulateEMPEffect(position, 500, 0.3)\n                    end\n                end\n            end\n        end\n        \n        -- Environmental warnings\n        if radiation.safety_status != \"safe\" then\n            if math.random() < 0.1 then\n                LocalPlayer():ChatPrint(\"[RADIATION] Warning: \" .. radiation.safety_status .. \" levels detected (\" .. math.floor(radiation.level) .. \" µSv/h)\")\n            end\n        end\n    end\n    \n    -- Hook environmental systems to game loop\n    hook.Add(\"Think\", \"SplinterCellEnvironmentalSystems\", UpdateEnvironmentalSystems)\n    \n    -- Console commands for environmental control\n    concommand.Add(\"sc_weather\", function(ply, cmd, args)\n        if args[1] then\n            local weatherType = args[1]\n            if WeatherSystem.types[weatherType] then\n                WeatherSystem.current.type = weatherType\n                WeatherSystem.current.intensity = tonumber(args[2]) or 0.5\n                LocalPlayer():ChatPrint(\"[WEATHER] Weather set to: \" .. weatherType)\n            else\n                LocalPlayer():ChatPrint(\"[WEATHER] Available types: \" .. table.concat(table.GetKeys(WeatherSystem.types), \", \"))\n            end\n        else\n            LocalPlayer():ChatPrint(\"[WEATHER] Current: \" .. WeatherSystem.current.type .. \" (\" .. math.floor(WeatherSystem.current.intensity * 100) .. \"%)\")\n        end\n    end)\n    \n    concommand.Add(\"sc_emp\", function(ply, cmd, args)\n        local intensity = tonumber(args[1]) or 0.5\n        local radius = tonumber(args[2]) or 1000\n        \n        SimulateEMPEffect(LocalPlayer():GetPos(), radius, intensity)\n        LocalPlayer():ChatPrint(\"[EMP] EMP effect simulated\")\n    end)\n    \n    concommand.Add(\"sc_radiation\", function(ply, cmd, args)\n        local level = tonumber(args[1]) or 100\n        \n        table.insert(RadiationSystem.sources, {\n            position = LocalPlayer():GetPos(),\n            intensity = level,\n            range = 500,\n            type = \"artificial\"\n        })\n        \n        LocalPlayer():ChatPrint(\"[RADIATION] Radiation source added (\" .. level .. \" µSv/h)\")\n    end)\n    \n    concommand.Add(\"sc_earthquake\", function(ply, cmd, args)\n        local magnitude = tonumber(args[1]) or 4.0\n        \n        SeismicSystem.activity = {\n            magnitude = magnitude,\n            epicenter = LocalPlayer():GetPos(),\n            depth = 5000,\n            duration = magnitude * 5,\n            frequency = 1 + (magnitude / 10)\n        }\n        \n        LocalPlayer():ChatPrint(\"[SEISMIC] Earthquake simulated: Magnitude \" .. magnitude)\n    end)\n    \n    concommand.Add(\"sc_atmospheric\", function(ply, cmd, args)\n        local altitude = LocalPlayer():GetPos().z\n        local atmospheric = CalculateAtmosphericProperties(altitude)\n        \n        print(\"=== ATMOSPHERIC CONDITIONS ===\")\n        print(\"Altitude: \" .. math.floor(altitude) .. \"m\")\n        print(\"Temperature: \" .. math.floor(atmospheric.temperature - 273.15) .. \"°C\")\n        print(\"Pressure: \" .. math.floor(atmospheric.pressure) .. \" Pa\")\n        print(\"Density: \" .. string.format(\"%.3f kg/m³\", atmospheric.density))\n        print(\"Humidity Ratio: \" .. string.format(\"%.6f\", atmospheric.humidity_ratio))\n    end)\n    \n    print(\"[SPLINTER CELL] Environmental Systems Loaded!\")\n    print(\"• Advanced Weather Simulation\")\n    print(\"• EMP Effect Simulation\")\n    print(\"• Atmospheric Modeling\")\n    print(\"• Radiation Detection\")\n    print(\"• Seismic Activity Monitoring\")\n    print(\"• Dynamic Environmental Effects\")\n    \nend